# 网络分层
- Applicaton 应用层
- presentation 表现层
- session 会话层
- transport 传输层
- newwork 网络层
- Data-link 数据链路 交换机
- physical 物理层


- A Agent 
- B Browser 

# 三次握手
- Hello B, 请求建立连接，我的seq是0，我的win是65535，我希望本次回应我的内容长度为0，本次我能接受的最大长度1460
- Hello A，我是B，消息收到。本次seq是0（双方seq独立计算）我回应你的ack是1（代表收到你seq为0的消息了）窗口大小8192
- 好的，B，我收到你的回应了，我现在给你发送的是seq1，我回应已读ack是1，我当前窗口的大小22289，我希望回应的长度为0，建立连接 over

- 第一次客户端发送syn包到服务器，并进入syn send状态，等待服务器确认
- 第二次服务器收到syn包，必须确认客户端的syn并且发送自己的syn包即syn+ack包，此时服务器进入syn——receive状态
- 第三次握手：客户端收到客户端的syn——ack包，向客户端发送ack包，此包发送完毕，客户端服务端进入establish状态
- 三次握手过程中传输的包里不包含数据，双方建立联系后，任何一方主动关闭连接之前，TCP连接都将被一直保持下去。

# 四次挥手
- TCP连接是全双工的，A给B发消息时B也可能在给A发消息，所以断开连接的时候双方必须都得知道
- A: B, 我这边需要关闭连接了，你准备一下（发了Fin信号给B，等待回应）
- B: A, 我收到了关闭信号，我还有数据没发好，你等我一下（回应A，带回去ACK最后一个消息，失败可以重发）
- B：我的数据已经传输完毕了，我可以关闭了，你回应我后，我就直接关闭了
- A：好的，我回应你一下（ACK），你收到就关闭吧
- B: 收到ACK后就直接关闭了，此过程不产生数据交互
- A: 等待一段时间后没有收到A的消息也关闭了(2msl)

- 第一次挥手：主机1，设置sequence number，向主机2发送一个FIN报文段，此时主机1进入fin——wait——1状态，表示主机1没有数据要发送给主机2了
- 第二次挥手：主机2收到主机1发送的FIN报文段，向主机1回了一个ACK报文段，ack number为sequence number加1，主机1进入fin——wait-2状态。主机2告诉主机1，我收到了你的关闭请求
- 第三次：主机2向主机1发送FIN报文段请求关闭连接，同时主机2进入last-ack状态
- 主机1收到主机2发送的FIN报文段，向主机2发送ACK报文段，然后主机1进入time-wait状态，主机2收到主机1的ack报文段后，就关闭了连接，此时主机1等待2msl后依然没有收到回复，则证明主机2已正常关闭连接，主机1也可以关闭了
- TCP是一种面向连接的，可靠的，基于字节流的传输层通信协议。TCP是全双工模式。意味这主机1发出fin报文段时，只是表示主机1已经没有数据要发送了，但是这是主机1还是可以接受来自主机2的数据，当主机2返回ack报文时，表示他已经知道主机1没有数据发送了，但主机2还是可以发送数据到主机1的，当主机2也发送了报FIN报文段时，这个时候就表示主机2也没有数据要发送了，就会告诉主机1，我也没有数据发送了，
